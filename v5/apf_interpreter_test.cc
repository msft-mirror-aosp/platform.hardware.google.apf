#include <stdint.h>
#include <string.h>
#include <gtest/gtest.h>

#ifdef __cplusplus
extern "C" {
#endif
int match_labels(const uint8_t* const target_name,
                 const int target_name_max_len, const uint8_t* const udp_payload,
                 const int udp_payload_len, const uint8_t** src);
int match_name(const uint8_t* const target_names, const int remain_program_len,
               const uint8_t* const udp_payload, const int udp_payload_len,
               const int question_type);
int calculate_checksum_and_get_dscp(uint8_t* const transmit_pkt,
                                    uint32_t transmit_pkt_len, uint8_t* dscp);

int calculate_checksum_and_get_dscp(uint8_t* const transmit_pkt,
                                    uint32_t transmit_pkt_len, uint8_t* dscp);
#ifdef __cplusplus
}
#endif

namespace apf {

TEST(ApfInterpreterTest, EmptyTargetName) {
  const uint8_t empty_target_name[] = { 0 };
  const uint8_t udp_payload[] = {1, 2, 3};
  const uint8_t* src = udp_payload;
  EXPECT_EQ(match_labels(empty_target_name, 1, udp_payload, 3, &src), -1);
}

TEST(ApfInterpreterTest, MatchLabelWithoutNameCompression) {
  const uint8_t matched_target_name[] =
      {0x04, 0x5f, 0x4e, 0x4d, 0x54,   // qname1 = _NMT._TCP.LOCAL
       0x04, 0x5f, 0x54, 0x43, 0x50,
       0x05, 0x4c, 0x4f, 0x43, 0x41, 0x4c, 0x00};
  const int matched_target_name_len = sizeof(matched_target_name);
  const uint8_t udp_payload[] =
      {0x00, 0x00, 0x00, 0x00, // tid = 0x00, flags = 0x00,
       0x00, 0x01, // qdcount = 1
       0x00, 0x00, // ancount = 0
       0x00, 0x00, // nscount = 0
       0x00, 0x00, // arcount = 0
       0x04, 0x5f, 0x6e, 0x6d, 0x74,   // qname1 = _nmt._tcp.local
       0x04, 0x5f, 0x74, 0x63, 0x70,
       0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00,
       0x00, 0x0c, 0x00, 0x01 }; // type=PTR, class=0x0001
  const int udp_payload_len = sizeof(udp_payload);
  const uint8_t* src = udp_payload + 12;

  EXPECT_EQ(match_labels(matched_target_name, matched_target_name_len, udp_payload, udp_payload_len, &src), 1);
  EXPECT_EQ(udp_payload + 29, src);

  const uint8_t not_matched_target_name[] =
      {0x04, 0x5f, 0x4d, 0x4d, 0x4d,   // qname1 = _MMM._tcp.local
       0x04, 0x5f, 0x74, 0x63, 0x70,
       0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00};
  const int not_matched_target_name_len = sizeof(not_matched_target_name);
  src = udp_payload + 12;
  EXPECT_EQ(match_labels(not_matched_target_name, not_matched_target_name_len, udp_payload, udp_payload_len, &src), 0);
  EXPECT_EQ(udp_payload + 29, src);
}

TEST(ApfInterpreterTest, MatchLabelWithNameCompression) {
  const uint8_t matched_target_name[] =
      {0x01, 0x42, // qname1 = B.LOCAL
       0x05, 0x4c, 0x4f, 0x43, 0x41, 0x4c, 0x00};
  const int matched_target_name_len = sizeof(matched_target_name);
  const uint8_t udp_payload[] =
      {0x00, 0x00, 0x00, 0x00, // tid = 0x00, flags = 0x00,
       0x00, 0x02, // qdcount = 2
       0x00, 0x00, // ancount = 0
       0x00, 0x00, // nscount = 0
       0x00, 0x00, // arcount = 0
       0x01, 0x61, 0x01, 0x62,   // qname1 = a.b.local
       0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00,
       0x00, 0x01, 0x00, 0x01,  // type=A, class=0x0001
      0xc0, 0x0e, // qname2 = b.local (name compression)
      0x00, 0x01, 0x00, 0x01 }; // type=A, class=0x0001
  const int udp_payload_len = sizeof(udp_payload);
  const uint8_t* src = udp_payload + 27;
  EXPECT_EQ(match_labels(matched_target_name, matched_target_name_len, udp_payload, udp_payload_len, &src), 1);
  EXPECT_EQ(udp_payload + 29, src);
}

TEST(ApfInterpreterTest, MatchLabelWithinfIniteloop) {
  const uint8_t matched_target_name[] =
      {0x01, 0x42, // qname1 = B.LOCAL
       0x05, 0x4c, 0x4f, 0x43, 0x41, 0x4c, 0x00};
  const int matched_target_name_len = sizeof(matched_target_name);
  const uint8_t udp_payload[] =
      {0x00, 0x00, 0x00, 0x00, // tid = 0x00, flags = 0x00,
       0x00, 0x02, // qdcount = 2
       0x00, 0x00, // ancount = 0
       0x00, 0x00, // nscount = 0
       0x00, 0x00, // arcount = 0
       0x01, 0x61, 0x01, 0x62,   // qname1 = a.b.local
       0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00,
       0x00, 0x01, 0x00, 0x01,  // type=A, class=0x0001
       0xc0, 0x1b, // corrupted pointer cause infinite loop
       0x00, 0x01, 0x00, 0x01 }; // type=A, class=0x0001
  const int udp_payload_len = sizeof(udp_payload);
  const uint8_t* src = udp_payload + 27;
  EXPECT_EQ(match_labels(matched_target_name, matched_target_name_len, udp_payload, udp_payload_len, &src), -1);
}

TEST(ApfInterpreterTest, MatchQuetions) {
  // target names = { A.B.LOCAL }
  const uint8_t target_names1[] = {0x01, 0x41, 0x01, 0x42, 0x05, 0x4c,
                                  0x4f, 0x43, 0x41, 0x4c, 0x00, 0x00};
  const int target_names_len1 = sizeof(target_names1);
  const uint8_t udp_payload[] = {
      0x00, 0x00, 0x00, 0x00,// tid = 0x00, flags = 0x00,
      0x00, 0x02,            // qdcount = 2
      0x00, 0x00,            // ancount = 0
      0x00, 0x00,            // nscount = 0
      0x00, 0x00,            // arcount = 0
      0x01, 0x61, 0x01, 0x62,// qname1 = a.b.local
      0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00,
      0x00, 0x01, 0x00, 0x01,// type=A, class=0x0001
      0xc0, 0x0e,                  // qname2 = b.local (name compression)
      0x00, 0x01, 0x00, 0x01};     // type=A, class=0x0001
  const int udp_payload_len = sizeof(udp_payload);
  EXPECT_EQ(match_name(target_names1, target_names_len1, udp_payload,
                       udp_payload_len, 0x01), 1);

  // target names = { A, B.LOCAL }
  const uint8_t target_names2[] = {0x01, 0x41, 0x00, 0x01, 0x42, 0x05, 0x4c,
                                     0x4f, 0x43, 0x41, 0x4c, 0x00, 0x00};
  const int target_names_len2 = sizeof(target_names2);
  EXPECT_EQ(match_name(target_names2, target_names_len2, udp_payload,
                       udp_payload_len, 0x01), 1);

  // target names = { C.LOCAL }
  const uint8_t target_names3[] = {0x01, 0x43, 0x05, 0x4c, 0x4f,
                                   0x43, 0x41, 0x4c, 0x00, 0x00};
  const int target_names_len3 = sizeof(target_names2);
  EXPECT_EQ(match_name(target_names3, target_names_len3, udp_payload,
                       udp_payload_len, 0x01), 0);
}

TEST(ApfInterpreterTest, MatchAnswers) {
    // target names = { A.B.LOCAL }
    const uint8_t target_names1[] = {0x01, 0x41, 0x01, 0x42, 0x05, 0x4c,
                                     0x4f, 0x43, 0x41, 0x4c, 0x00, 0x00};
    const int target_names_len1 = sizeof(target_names1);
    const uint8_t udp_payload[] = {
        0x00, 0x00, 0x84, 0x00, // tid = 0x00, flags = 0x8400,
        0x00, 0x00, // qdcount = 0
        0x00, 0x02, // ancount = 2
        0x00, 0x00, // nscount = 0
        0x00, 0x00, // arcount = 0
        0x01, 0x61, 0x01, 0x62, // qname1 = a.b.local
        0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00,
        0x00, 0x01, 0x80, 0x01, // type=A, class=0x8001
        0x00, 0x00, 0x00, 0x78, // ttl = 120
        0x00, 0x04, 0xc0, 0xa8, 0x01, 0x09, // rdlengh = 4, rdata=192.168.1.9
        0xc0, 0x0e, // qname2 = b.local (name compression)
        0x00, 0x01, 0x80, 0x01, // type=A, class=0x8001
        0x00, 0x00, 0x00, 0x78, // ttl = 120
        0x00, 0x04, 0xc0, 0xa8, 0x01, 0x09  // rdlengh = 4, rdata=192.168.1.9
    };
    const int udp_payload_len = sizeof(udp_payload);
    EXPECT_EQ(match_name(target_names1, target_names_len1, udp_payload,
                         udp_payload_len, -1), 1);

    // target names = { A, B.LOCAL }
    const uint8_t target_names2[] = {0x01, 0x41, 0x00, 0x01, 0x42, 0x05, 0x4c,
                                     0x4f, 0x43, 0x41, 0x4c, 0x00, 0x00};
    const int target_names_len2 = sizeof(target_names2);
    EXPECT_EQ(match_name(target_names2, target_names_len2, udp_payload,
                         udp_payload_len, -1), 1);

    // target names = { C.LOCAL }
    const uint8_t target_names3[] = {0x01, 0x43, 0x05, 0x4c, 0x4f,
                                     0x43, 0x41, 0x4c, 0x00, 0x00};
    const int target_names_len3 = sizeof(target_names2);
    EXPECT_EQ(match_name(target_names3, target_names_len3, udp_payload,
                         udp_payload_len, -1), 0);
}

TEST(ApfInterpreterTest, Ipv4UdpChecksumCalculation) {
    uint8_t ipv4_udp_pkt[] = {
        0x01, 0x00, 0x5e, 0x00, 0x00, 0xfb, 0x38, 0xca, 0x84, 0xb7, 0x7f,
        0x16, 0x08, 0x00, 0x45, 0x00, 0x00, 0x3f, 0x43, 0xcd, 0x40, 0x00,
        0xff, 0x11, 0x00, 0x00, 0xc0, 0xa8, 0x01, 0x03, 0xe0, 0x00, 0x00,
        0xfb, 0x14, 0xe9, 0x14, 0xe9, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x00,
        0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x62, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00, 0x00, 0x01, 0x80,
        0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x04, 0xc0, 0xa8, 0x01, 0x09,
    };
    uint8_t dscp = 0xff;
    EXPECT_EQ(calculate_checksum_and_get_dscp(ipv4_udp_pkt,
                  sizeof(ipv4_udp_pkt), &dscp),
              1);
    // verify dscp
    EXPECT_EQ(dscp, 0);
    // verify ipv4 header checksum
    EXPECT_EQ(ipv4_udp_pkt[24], 0x95);
    EXPECT_EQ(ipv4_udp_pkt[25], 0x39);
    // verify layer 4 checksum
    EXPECT_EQ(ipv4_udp_pkt[40], 0xa7);
    EXPECT_EQ(ipv4_udp_pkt[41], 0x3d);
}

TEST(ApfInterpreterTest, Ipv6UdpChecksumCalculation) {
    uint8_t ipv6_udp_pkt[] = {
        0x33, 0x33, 0x00, 0x00, 0x00, 0xfb, 0x38, 0xca, 0x84, 0xb7, 0x7f,
        0x16, 0x86, 0xdd, 0x60, 0x09, 0xf4, 0x6b, 0x00, 0x2b, 0x11, 0xff,
        0x24, 0x0d, 0x00, 0x1a, 0x03, 0xa6, 0xc4, 0x00, 0xb7, 0x5a, 0xb4,
        0x85, 0x28, 0x10, 0xad, 0x6b, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb,
        0x14, 0xe9, 0x14, 0xe9, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x84,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x62,
        0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00, 0x00, 0x01, 0x80, 0x01,
        0x00, 0x00, 0x00, 0x78, 0x00, 0x04, 0xc0, 0xa8, 0x01, 0x09};
    uint8_t dscp = 0xff;
    EXPECT_EQ(calculate_checksum_and_get_dscp(ipv6_udp_pkt,
                                              sizeof(ipv6_udp_pkt), &dscp),
              1);
    EXPECT_EQ(dscp, 0);
    // verify layer 4 checksum
    EXPECT_EQ(ipv6_udp_pkt[60], 0x1c);
    EXPECT_EQ(ipv6_udp_pkt[61], 0xbd);
}

TEST(ApfInterpreterTest, Ipv6Icmp6ChecksumCalculation) {
    uint8_t ipv6_icmp6_pkt[] = {
        0xcc, 0x1a, 0xfa, 0xc7, 0xd2, 0xd8, 0xbc, 0xd0, 0x74, 0x58, 0xf1, 0x4f,
        0x86, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3a, 0xff, 0xfe, 0x80,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x12, 0x11, 0x2c, 0xdc, 0x04,
        0x35, 0x11, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x88, 0x00, 0x00, 0x00, 0x40, 0x00,
        0x00, 0x00, 0x24, 0x0d, 0x00, 0x1a, 0x03, 0xa6, 0xc4, 0x00, 0xfd, 0x3d,
        0x12, 0xb7, 0x90, 0xb6, 0xe9, 0xd2,
    };
    uint8_t dscp = 0xff;
    EXPECT_EQ(calculate_checksum_and_get_dscp(ipv6_icmp6_pkt,
                                              sizeof(ipv6_icmp6_pkt), &dscp),
              1);
    EXPECT_EQ(dscp, 0);
    // verify layer 4 checksum
    EXPECT_EQ(ipv6_icmp6_pkt[56], 0x8a);
    EXPECT_EQ(ipv6_icmp6_pkt[57], 0x09);
}

}  // namespace apf
